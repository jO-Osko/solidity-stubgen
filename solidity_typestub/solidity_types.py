from __future__ import annotations

import dataclasses
import re
from abc import abstractmethod
from collections import defaultdict
from typing import Any, DefaultDict, Dict, Generic, List, Optional, Type, TypeVar

from hexbytes import HexBytes

from solidity_typestub.deserializers import (
    AddressTypeDecoder,
    ArrayTypeDecoder,
    BoolTypeDecoder,
    BytesTypeDecoder,
    IntTypeDecoder,
    SolidityTypeDecoder,
    StructTypeDecoder,
)

header = [
    "# Autogenerated by solidity-typestub",
    "from typing import List, Tuple, overload",
    "from hexbytes import HexBytes",
    "from typing_extensions import TypedDict",
    "",
    "AddressType = str",
    "",
]

decoder_data_header = [
    "# Autogenerated by solidity-typestub",
    "from typing import Any, cast",
    open("solidity_typestub/deserializers.py", "r").read(),
]


@dataclasses.dataclass(frozen=True)
class ParsingState:
    types: dict[str, "Struct"] = dataclasses.field(default_factory=dict)

    def add_type(self, typ: "Struct") -> "ParsingState":
        new_dict = self.types.copy()
        new_dict[typ.original_name] = typ
        return dataclasses.replace(self, types=new_dict)

    @classmethod
    def empty(cls) -> "ParsingState":
        return cls(types={})


T = TypeVar("T", bound="Parsable", covariant=True)


@dataclasses.dataclass(frozen=True)
class ParsingResult(Generic[T]):
    state: ParsingState
    parsed: T


@dataclasses.dataclass(frozen=True)
class Parsable:
    @classmethod
    def parse(
        cls: Type[T], data: Dict[str, Any], state: ParsingState
    ) -> ParsingResult[T]:
        raise NotImplementedError()


@dataclasses.dataclass(frozen=True)
class SolidityType(Parsable):
    name: str

    def python_type(self) -> type:
        raise NotImplementedError()

    def python_type_repr(self) -> str:
        return self.python_type().__name__

    def get_decoder(self) -> SolidityTypeDecoder:
        raise NotImplementedError()

    @classmethod
    def parse(
        cls, data: Dict[str, Any], state: ParsingState
    ) -> ParsingResult[SolidityType]:
        typ: str = data["type"]
        array_pat = re.compile(r"(?P<typ>.*)\[(?P<size>\d*)]$")
        # Once mypy supports match we can upgrade this and use walrus operator
        if re.match(array_pat, typ):
            match = re.match(array_pat, typ)
            assert match
            data = data.copy()
            data["type"] = re.sub(array_pat, r"\g<typ>", data["type"])
            size = match.groupdict().get("size")
            parsed = SolidityType.parse(data, state)
            return ParsingResult(
                parsed.state,
                Array(typ, parsed.parsed, size=int(size) if size else None),
            )
        elif typ.startswith("uint") or typ.startswith("int"):
            return ParsingResult(state, Integer(typ))
        elif typ == "bytes":
            return ParsingResult(state, BytesType(typ))
        elif typ.startswith("bytes"):
            return ParsingResult(state, Bytes(typ))
        elif typ == "string":
            return ParsingResult(state, String(typ))
        elif typ == "address":
            return ParsingResult(state, Address(typ))
        elif typ == "bool":
            return ParsingResult(state, Bool(typ))
        elif typ == "tuple":
            name = data["internalType"]
            assert name.startswith("struct ")
            name = name.replace("struct ", "")
            components: Dict[str, SolidityType] = {}
            for member in data["components"]:
                parsed = SolidityType.parse(member, state)
                components[member["name"]] = parsed.parsed
                state = parsed.state

            parsed_down = Struct(name, components)
            state = state.add_type(parsed_down)
            return ParsingResult(state, parsed_down)
        else:
            print("UNRECOGNIZED", typ)
            assert False


@dataclasses.dataclass(frozen=True)
class ValueType(SolidityType):
    @property
    @abstractmethod
    def python_type(self) -> type:
        raise NotImplementedError()


@dataclasses.dataclass(frozen=True)
class Bool(SolidityType):
    def python_type(self) -> type:
        return bool

    def get_decoder(self) -> SolidityTypeDecoder:
        return BoolTypeDecoder()


@dataclasses.dataclass(frozen=True)
class Integer(SolidityType):
    size: int = dataclasses.field(init=False)

    def __post_init__(self) -> None:
        size = self.name.replace("uint", "").replace("int", "")
        size_i = int(size) if size else 256
        object.__setattr__(self, "size", size_i)

    def python_type(self) -> type:
        return int

    def get_decoder(self) -> SolidityTypeDecoder:
        return IntTypeDecoder()


class AddressType:
    address: str

    __name__ = "AddressType"


@dataclasses.dataclass(frozen=True)
class Address(SolidityType):
    def python_type(self) -> type:
        return AddressType

    def get_decoder(self) -> SolidityTypeDecoder:
        return AddressTypeDecoder()


@dataclasses.dataclass(frozen=True)
class Bytes(SolidityType):
    size: int = dataclasses.field(init=False)

    def __post_init__(self) -> None:
        size = int(self.name.replace("bytes", ""))
        assert size <= 32, "Bytes must be <= 32"
        object.__setattr__(self, "size", size)

    def python_type(self) -> type:
        return HexBytes

    def get_decoder(self) -> SolidityTypeDecoder:
        return BytesTypeDecoder()


class BytesType(SolidityType):
    def python_type(self) -> type:
        return HexBytes

    def get_decoder(self) -> SolidityTypeDecoder:
        return BytesTypeDecoder()

@dataclasses.dataclass(frozen=True)
class String(SolidityType):
    def python_type(self) -> type:
        return str

    def get_decoder(self) -> SolidityTypeDecoder:
        return BytesTypeDecoder()


@dataclasses.dataclass(frozen=True)
class Array(SolidityType):
    internal_type: SolidityType
    size: Optional[int] = None

    def python_type(self) -> type:
        # return List[self.internal_type.python_type()]
        return List[Any]

    def python_type_repr(self) -> str:
        return f"List[{self.internal_type.python_type_repr()}]"

    def get_decoder(self) -> SolidityTypeDecoder:
        return ArrayTypeDecoder(self.internal_type.get_decoder())


@dataclasses.dataclass(frozen=True)
class Struct(SolidityType):
    original_name: str
    members: Dict[str, SolidityType] = dataclasses.field(default_factory=dict)
    name: str = dataclasses.field(init=False)

    def __post_init__(self) -> None:
        object.__setattr__(
            self, "name", self.original_name.replace(".", "__").rstrip("[]")
        )

    def python_type(self) -> type:
        raise NotImplementedError()

    def python_type_repr(self) -> str:
        return self.name

    def get_decoder(self) -> SolidityTypeDecoder:
        return StructTypeDecoder({m: t.get_decoder() for m, t in self.members.items()})


@dataclasses.dataclass(frozen=True)
class AbiType(Parsable):
    name: str
    internal_type: Optional[str]
    typ: SolidityType
    components: List[Any] = dataclasses.field(default_factory=list)

    @classmethod
    def parse(cls, data: Dict[str, Any], state: ParsingState) -> ParsingResult[AbiType]:
        parsed = SolidityType.parse(data, state)
        return ParsingResult(
            parsed.state,
            cls(
                data["name"],
                data.get("internalType"),
                parsed.parsed,
            ),
        )

    @property
    def printable_name(self) -> str:
        return self.name or "_"


@dataclasses.dataclass(frozen=True)
class SolidityMethod(Parsable):
    @classmethod
    def parse(
        cls, data: Dict[str, Any], state: ParsingState
    ) -> ParsingResult[SolidityMethod]:
        data_type = data["type"]
        if data_type == "function":
            return Function.parse(data, state)
        if data_type == "constructor":
            return Constructor.parse(data, state)
        else:
            assert False, f"Unsupported method type: {data_type}"

    def stub_source(self) -> str:
        raise NotImplementedError()


@dataclasses.dataclass(frozen=True)
class Function(SolidityMethod):
    name: str
    inputs: List[AbiType] = dataclasses.field(default_factory=list)
    outputs: List[AbiType] = dataclasses.field(default_factory=list)
    state_mutability: Optional[str] = None

    @classmethod
    def parse(
        cls, data: Dict[str, Any], state: ParsingState
    ) -> ParsingResult[Function]:
        inputs: list[AbiType] = []
        for i in data["inputs"]:
            parsed = AbiType.parse(i, state)
            inputs.append(parsed.parsed)
            state = parsed.state

        outputs: list[AbiType] = []
        for i in data["outputs"]:
            parsed = AbiType.parse(i, state)
            outputs.append(parsed.parsed)
            state = parsed.state

        return ParsingResult(
            state,
            cls(
                name=data["name"],
                inputs=inputs,
                outputs=outputs,
            ),
        )

    def stub_source(self) -> str:
        input_data: List[str] = ["self"] + [
            f"{i.printable_name}: {i.typ.python_type_repr()}"
            for i in self.inputs
            if i.typ
        ]
        inputs = ", ".join(input_data)
        output_data = [
            i.typ.python_type_repr() for i in self.outputs if i.typ is not None
        ]
        if len(output_data) == 1:
            outputs = output_data[0]
        elif output_data:
            outputs = "Tuple[" + ", ".join(output_data) + "]"
        else:
            outputs = "None"
        return f"\tdef call({inputs}) -> {outputs}: ..."

    @property
    def class_function_name(self) -> str:
        return f"Function{self.name}"


@dataclasses.dataclass(frozen=True)
class Constructor(Function):
    @classmethod
    def parse(
        cls, data: Dict[str, Any], state: ParsingState
    ) -> ParsingResult[Constructor]:
        inputs: list[AbiType] = []
        for i in data["inputs"]:
            parsed = AbiType.parse(i, state)
            inputs.append(parsed.parsed)
            state = parsed.state

        return ParsingResult(
            state,
            cls(
                "constructor",
                inputs=inputs,
            ),
        )


@dataclasses.dataclass(frozen=True)
class Contract:
    name: str
    raw_abi: List[Dict[str, Any]]
    function_data: List[Function] = dataclasses.field(init=False)
    state: ParsingState = dataclasses.field(init=False)

    def __post_init__(self) -> None:
        state = ParsingState.empty()
        data: List[SolidityMethod] = []
        for abi in self.raw_abi:
            parsed = SolidityMethod.parse(abi, state)
            if parsed:
                data.append(parsed.parsed)
                state = parsed.state

        object.__setattr__(
            self,
            "function_data",
            data,
        )

        object.__setattr__(self, "state", state)

    @classmethod
    def from_json(cls, json: Dict[str, Any]) -> Contract:
        return cls(json["contractName"], json["abi"])

    def stub_source(self) -> tuple[List[str], List[str]]:
        function_data: DefaultDict[str, List[str]] = defaultdict(list)

        functions: Dict[str, Function] = {}

        for func in self.function_data:
            function_data[func.name].append(func.stub_source())
            functions[func.name] = func

        data = []
        decoder_data = []

        for typ in self.state.types.values():
            data.extend(
                [
                    f"# {typ.original_name}",
                    f'{typ.name} = TypedDict("{typ.name}", {{',
                ]
                + [
                    f'    "{comp}": "{typ.python_type_repr()}", # {typ.name}'
                    for (comp, typ) in typ.members.items()
                ]
                + ["})"]
            )
            decoder_data.extend(
                [
                    f'def decode_{typ.name}(data: dict[str, Any]) -> "{typ.name}":',
                    f'    return cast("{typ.name}",{typ.get_decoder()}.process(data))',
                ]
            )

        for fname, methods in function_data.items():
            function_contract: List[str] = [
                f"class {functions[fname].class_function_name}:"
            ]

            for method in methods:
                if len(methods) > 1:
                    function_contract.append("\t@overload")
                function_contract.append(f"{method}")
            data.extend(function_contract)

        data.append(f"class {self.proxy_name}:")
        for fname in function_data:
            data.append(
                f"\tdef {fname}(self) -> {functions[fname].class_function_name}: ..."
            )

        data.extend(
            [
                f"class {self.name}:",
                f"\tfunctions : {self.proxy_name}",
            ]
        )

        return data, decoder_data

    @property
    def proxy_name(self) -> str:
        return f"Proxy{self.name}"
